Прямых констант в js  не бывает
infinity и NaN относятся к числовому типу данных
Null- тип данных(простой, но в typeof(null) выдёт object- это общепризнанная ошибка). Когда чего-то просто не существует. 
Undefined. Что-то существует, но не имеет никакого значения	
Объекты- комплексный тип данных
Массив- частный случай объекта. Это объект, у которого ключ- номер по порядку. 


const arrObj = {
  0: "a",
  1: "b",
  name: "c",
};
console.log(arrObj.1);  /* ошибка */
console.log(arrObj[1]); /* получится, поэтому квадратные скобки будут надёжнее*/
console.log(arrObj["name"]); /* без кавычек- ошибка */ если без кавычек, то js думает, что вы обращаетесь к какой-то переменной(а у нас свойство(ключ), а не переменная)
При присваивани тоже самое : arrObj['b'] = 1234 /без кавычек- ошибка

Общение с пользователем: команды: 1. Alert   2.Confirm("  текст  ")   3.Prompt(" текст  ", " значение по умолчнию ")   Они сществуют только внутри браузера

Вся информация, которая приходит от пользователя, будет в виде СТРОК

Унарный плюс- плюс, который использует только один аргумент


Работа с git: ситуация, когда в удал. репозиторий "новее", чем на локальном компьютере: хочешь закомитить измененные файлы и 
выдаёт ошибку---> нужно ввести команду git pull--> произойдёт merge(слияние) репозиториев( далее там нужно ввести :wq!)

Сетевые протоколы:
есть HTTPS, а есть SSH : 
SSH- Secure Shell сетевой протокол для удалённого управления операционными системами и передачей файлов. Он шифрует траффик и делает подключения безопасными
Для создания безопасного соединения используются ключи. Ключи хранятся на локальном компьютере(в специальном файле) и на гитхабе(в нашем случае). При передаче данных авторизация 
в аккаунт гитхаба идёт не через логин и пароль, а через сравнение ключей( если совпадают, то передача разрешается)


Работа с объектами и массивами:
- Array.isArray(массив) - проверка, является ли сущность массивом
- перебор массива:
////
const personalPlanPeter = {
  name: "Peter",
  age: "29",
  skills: {
    languages: ["ru", "eng"],
    programmingLangs: {
      js: "20%",
      php: "10%",
    },
    exp: "1 month",
  },
};

 for (item of personalPlanPeter.skills.languages) {
      str += `${item.toUpperCase()} `;
////

- Метод «arr.forEach(callback[, thisArg])» используется для перебора массива. Он для каждого элемента массива вызывает функцию callback 
(минусс метода в том,что тут нельзя использовать операторы break и continue):
////

    arr.forEach(member => {
        str += `${member} `
    });
////
- метод Object.keys(объект) - возвращает массив, содержащий свойства объекта.
- метод Object.values(объект) - возвращает массив, содержащий значения свойств объекта

- Поверхностная копия объектов происходит, когда мы копируем объект, который содержит в себе другой объект(этот объект будет ссылаться на старый объект)
////
mainObj = {
	a: 1,
	b: 2,
	c: {		   // вот тут будет поверхностная копия
		d: 3,    
		e: 4,
	   },
	};
let objCopy = {};
for( let key in mainObj){
	objCopy[key] = mainObj[key]
   };

- Соединение нескольких объектов: Object.assign(имена объектов)---> можно исп. этот приём для копирования объекта: Object.assign({}, arr): скопировали объект arr
  Чтобы не менять оригинал, а только копию делаем следующее:
////
const restorantData = {
    menu: [
        {
            name: 'Salad Caesar',
            price: '14$'
        },
        {
            name: 'Pizza Diavola',
            price: '9$'
        },
        {
            name: 'Beefsteak',
            price: '17$'
        },
        {
            name: 'Napoleon',
            price: '7$'
        }
    ],
    waitors: [
        {name: 'Alice', age: 22}, {name: 'John', age: 24}
    ],
    averageLunchPrice: '20$',
    openNow: true
};

function transferWaitors(data) {
    const copy = Object.assign({}, data);

    // Нам просто нужно менять весь массив данных,
    // а не лезть напрямую менять каждого из сотрудников
    // Так как это верхний уровень объекта, то значение 
    // будет меняться только у копии
    copy.waitors = [{name: 'Mike', age: 32}];
    return copy;
}

transferWaitors(restorantData);
////

- Копирование старого массива: const newArr = oldArr.slice();
- оператор разворота(разворачивает структуру и превращает её в набор каких-то данных)- spread-оператор:
////
const video = ['a', 'b', 'c'],
	audio = ['d', 'e', 'f'],
	internet= [...video, ...audio, 'g', 'h'];
////
Аналогично работает и с объектами

ООП:
- ООП- это наука о том, как правильно делать архитектуру
- JS- объектно-ориентированный язык
- JS- прототипно ориентированный язык(частный случай ООП)
- в ОЫ все строится на прототипах 
- Объект- сущность с набором свойств и методов
- при работе например со строками(примитивный тип данных) мы сначала создаём строку(typeof(str) выдаст string), а при работе с ним(при вызове метода) JS времнно
  превращает его в объект
- прототипно-ориентированное наследование: например у нас есть машины : она с разными марками, диаметром колёс и т.д., но
  прототипом для них будет то, что они все являются легковыми . Также и с массивами: они могут быть разными, но операции над массивами выполняются одни и те же.
  Когда мы создаём новый массив, мы создаём экземпляр прототипа массива
- Каждый(вроде как) объект имеет свой прототип, который в конечном счёте ссылается на Object, а тот в свою очередь на null. Благодаря прототипам объект как бы имеет свойств прототипа
  (если мы их захотим вывести на экран), но при необходимости мы можем обратиться к этим свойствам

- В проектах можно создать большой прототип модального окна, а от этого прототипа можно создать много маленьких окон
- Установка прототипа(в динмаике, то есть если два объекта уже были созданы):
////
Object.setPrototypeOf(alex, soldier);
////
- Установка прототипа сразу при создании объекта:
////
const chad = Object.create(soldier);
////

- рефакторинг кода- переписывание кода под новые условия или новые задачи

ДИНАМИЧЕСКАЯ ТИПИЗАЦИЯ:
-Всё, что получаем от пользователя, будет типом данных - строка
- возможность одного типа данных превращаться в другой
- методы:
  #превращение в строку:
   *String(); - редко пользуются этим способом
   *Конкатенация - (5 + '') - при сложении со строкой у нас всё равно получается строка
- пример:
////
      const num = 5;(номер каталога по порядку)
	console.log("https://vk.com/catalog/" + num);
////
  #превращение в число:
   *Number('4'); -пользуются краааайне редко
   *(+'5') - унарный плюс
   *parseInt("15px", 10)

EX.:
////
	let answ = +prompt("Hello, "");
////
  #превращение в логическое значение:
	ложь: 0, '', null, undefined, NaN
	правда: всё остальное

	*EX.:
////
	let switcher = null;
	
	if (switcher) {
		console.log('Working...');	// не сработает
	}
	
	switcher = 1;
	
	if (switcher) {
		console.log('Working...');      // сработает
	}
////
	*Boolean('4');
	*(!!"4444");  // двойное отрицание

ЗАМЫКАНИЕ И ЛЕКСИЧЕСКОЕ ОКРУЖЕНИЕ:
	-function declaration- явление, когда функция уже существует(её значение undefined) ещё до того, как код начал выполняться построчно
	- в JS у каждой выполняемой функции, блока кода и скрипта есть связанный с ними внутренний(скрытый от нас) объект - лексическое окружение( lexical environment)
	- Это лексическое окружение делится на 2 части:
		*внутреннее - объект, в котором как свойства хранятся все локльные переменные этой функции(local в sources)
		*внешнее - свойства, которые находятся вне функции(script в sources)
	- замыкание- это когда функция пытается найти что-то внутри себя и если она этого не находит, то она обращается к чему-то, что находится более глобально
	- любая переменная - это свойство объекта лексического окружения
	- лексическое окружение- это технический объект. Напрямую мы с ним никогда не будет работать. Его работу контролирует интерпретатор( в нашем случае браузер
	-РАБОТА ФУНКЦИИ:
	1. Функция стартует с того, что она внутри себя создаёт те переменные, которые в ней созданы( let number = 4; //// тут сначала number = undefined )
	2. Вызов и создание внутреннего и внешнего(глоабального) лексического окружения 
	3. Присвоение значений переменным
	4. Работа с переменными
	5. Сначала функция ищет локальные переменные, а затем глобальные( и так до тех пор пока не дойдёт до самой глобальной области видимости)
	после того как функция отработает, её лексическое окружение уничтожается за ненадобностью 
	- Каждый вызов функции- это создание нового лексического окружения(внутреннего и внешнего), со своими специфическими свойствами(после завершения выполнения внутреннее
	  лкесическое окружение уничтожается)
      - Когда мы возвращаем какую-то функцию в переменную, к примеру, внутренняя лексическая область окружения 
	  будет уничтожена, так как она больше не нужна, но наружу мы позвращаем описание этой функции(что происходит внутри)-объвление этой функции и её замыкания(на что она 	   	  будет ссылаться):
	 	*это как рюкзак с переменными, которые были в области видимости в период создания функции (EX.: если у нас есть функция , которая  объявл. переменные, а затем
	  	возвр. функцию, которая использует эту переменные(она всегда будет хранить ссылку на эту глобальную переменную). Дальнейшее использование этой функции(кот. возвр.
  	  	функцию) для присваивания её какой-то переменной и есть то, что описывалось выше)
	- Closure - замыкание(свойство лексического окружения)
	- Механизм, благодаря которому функция знает, что ей брать и помещать в лексическое окружение - скрытое свойство Environment, которое ссылается на лексическое окружение
	  места, где эта функция была создана( именно благодаря этому свойству функция знает, что положить к себе в замыкание
EX.:
////
	function createCounter(){
		let counter = 0;
		
		const myFunction = function() {
			counter = counter + 1;
			return counter;
		}
		return myFunction;
	}

	const increment = createCounter();
	const c1 = increment();
	const c2 = increment();
	const c3 = increment();
	console.log(c1, c2, c3);     //выведет: 1 2 3
////
	- замыкания- это коллекция всех переменных из области видимости во время создания функции(рюкзак функции)
////
	let b = 1;
function createCounter() {
  let counter = 0;

  const myFunction = function () {
    counter = counter + 1;     /* замыкание */
    b = b + 1;                  /* b к замыканиям не относится, но она также изменяется в глобальной области видимости( то есть тут идёт ссылка на глобальную переменную) */
    return counter + b;
  };
  return myFunction;
}

const increment = createCounter();
const c1 = increment();
const c2 = increment();
const c3 = increment();
console.log(c1, c2, c3);
console.log(b);
////


////
let a = [1];
let b = [1];
console.log(a === b);	//выведет false
////
console.log(4 || 3);	// выведет 4(или запинается на лжи)
////
console.log(4 && 3);	//выведет 3(если оба true - выводится последняя цифра)
////

РАБОТА С DOM:
- Объект window представляет собой окно, содержащее DOM документ
- DOM — это независящий от платформы и языка программный интерфейс, позволяющий программам и скриптам получить доступ к содержимому HTML-, XHTML- и XML-документов, а также изменять содержимое, структуру и оформление таких документов. 
- в JS объектная модель документа представлена методом document(работает только внутри браузера)
////
const btns = document.getElementsByTagName('button');    //образуется псевдомассив(массив без методов)
////
- У метода querySelectorAll() есть свойтсво forEach()
- инлайн-стили имеют самый главный приоритет
- в js при задании инлайн стилей нужно обращаться именно к конкретному элементу: btns[1].style.borderRadius = '100%'
- способ задания сразу нескольких инлайн-стилей:  box.style.cssText = 'background-color: blue; width: 500px';
- для измененя сразу же несколькоих элементов: 
	1)for - используется крайне редко
	2)element.forEach(item =>{
		item.style.backgroundColor = 'blue';
		}
- создание элемента только в js: const div = document.createElement('div');
- создание текстового узла(он появится на страничке): const text = document.createTextNode('Тут был я');
- при работе со стилями, мы не будем работать с инлайн стилями---> будем использовать классы:
	* стилизация элекментов, которые мы создали
		div.classList.add('black');
- любой элемент можно вставить(удалить, заменить) туда, куда мы захотим, но только по отношению к другому элементу:
	*современные методы для работы со странцией:
		>элемент.append(div)- берём элемент div и ставим его в самый конец элемента
		>элемент.prepend(div)- берём элемент div и ставим его в самое начало элемента
		>element.before(div)- div перед element
		>element.after(div)- div после element
		>element.remove()- удаление элемента
		>element.replaceWith(div)- замена элементом div
	*методы, которые устарели, но мы можем встретить их в своём коде:
		>document.body.appendChild(div) - то же самое, что и document.body.append(div);
		>родитель.insertBefore([блок,который вставляем] , [перед каким элементом мы всталяем])
		>родитель.removeChild(удаляемый элемент)
		>wrapper.replaceChild([чем заменяем], [что заменяем])
- добавление текст в html:
	*div.innerHTML = "Hello World!";
		>можно элементы HTML:
			^div.innerHTML = "<h1>Hello World!</h1>";
	*div.textContent = "Hello" - работает только с текстом(нельзя исп. элекменты HTML)
	*div.insertAdjacentHTML('beforebegin - перед элементом; afterbegin - в начало элемента; beforeend - перед концом; afterend - после элемента', '<h2>Hello</h2>')

- queryselector - выводит в консоль html-конструкцию
- querySelectorAll - выводит в консоль NodeList
- Объект NodeList представляет собой коллекцию узлов. Такой объект возвращается, когда используются такие методы как document.querySelectorAll(), document.getElementsByName()  
  или свойство Node.childNodes. Является псевдомассивом.

СОБЫТИЯ И ИХ ОБРАБОТЧИКИ:
- 3 способа назначить обработчики событий:
	1)в HTML прописываем onclick="alert('Click')" в качестве атрибута - почти не используется
	2)Использование свойства(.onclick) DOM-дерева для событий:		- тоже почти не используется(проблема - при повторении событий в коде выполняется второе 	   		событие(первое игнорируется)+ иногда мы хотим удалять обработчики событий после того как взаимодействие произошло, а с таким способом удалить обработчик нельзя
		////
		const btn = document.querySelectorAll("button");
		btn.onclick = function (){ //теперь onclick это не свойство, а метод(благодаря объявлению функции)
			alert("Click");
		}
		////
	3)методы addEventListener и removeEventListener:
		////
		btn.addEventListener('click', () =>{
			alert("Click");
		})      //мы добавляем обработчик событий(слушатель за событиями). Мы говорим, что js будет следить за этим элементом и если произошло событие, которое  					    описывается в скобках первым аргументом(название события),то он запустит обработчик(второй аргумент)
		////
		*при использовании этого метода будут выполняться все обработчики вне зависимости от их количества.
- события в js выполняются в порядке очереди: как только событие поступило, оно добавляется в очередь независимо от других событий
- объект Event(событие) - передаётся как аргумент в коллбэк функцию(название не играет роли, он всегда передаётся первым аргументом)
- Объект Event описывает событие, произошедшее на странице. Одной из причин возникновения событий являются действия пользователя, такие как клики мышкой MouseEvent или ввод с клавиатуры KeyboardEvent. Существует множество различных событий, которые будут иметь разный набор информации о них.
	*удаление обработчика события:
		////
		let i = 0;
		const deleteElement = (e) => {
			console.log(e.target);
			i++;
			if(i == 1){
				btn.removeEventListener('click', deleteElement);	// если условие сработало, то удаляем этот обработчик
			}
		};
		btn.addEventListener('click', deleteElemet);   // !второй аргумент идёт без круглых скобок после названия функции, так как мы просто ссылаемся на эту функцию, 											   которая будет выполняться после клика, а не вызываем эту функцию
		////
- всплытие событий - когда обработка события сначала срабатывает на вложенном элементе, а затем на его родителе(в случае, если мы назначили одно и то же событие на оба
  элемента)
- Отмена стандратного поведения браузера:
	////
	event.preventDefault();
	////
- нельзя назначать события переменным, которые соедржат несколько элементов странички(полученные через querySelectorAll), так как данная переменная - это псевдомассив. а у 
  массива нет такого метода как addEventListener и т.д.---> нужно этот всевдомассив перебрать и назначить каждому обработчики:
	////
	const btns = document.querySelectorAll('button');
	btns.forEach(btn => {
		btn.addeventListener('click', deleteElement)
	});
	////
- 3-ий аргумент метода addeventListener - options(опции): {once: true} - к примеру

НАВИГАЦИЯ ПО DOM:
- document.documentElement - получение тега <html> - самого главного тега (содержимое всей страницы)
- свойство childNodes - узлы, которые является детьми элемента, у которого мы вызвали это свойство - на выходе получается псевдомассив: 
////
console.log(document.body.childNodes);	//NodeList(10) [text, button#btn, text, button, text, button, text, a, text, script]
NodeList(10) [text, button#btn, text, button, text, button, text, a, text, script]
- разница между DOM-элементами и DOM-узлами: всё, что находится в HTML, является узлом , но не всё, что является узлом, будет элементом
- перенос строки например, который никкак не обозначается в вёрстке тоже является DOM-узлом - называется text
- .firstChild, .lastChild- первый и последние узлы родителя
- .nextSibling, .previousSibling
---->все вышеперечисленные свойства были командами, которые отталкивались от родителя ----> далее покажем свойства, которые отталкиваются от всех элементов страницы
- .parentNode - получаем родителя элемента( можно несколько раз продублировать свойство - выйдем уже на родителя родителя)
- дата-атрибуты -атриюуты, на которые очень удобно ориентироваться в js:
	////	
	document.querySelector('[data-current]').
---> все вышеперечисленные свойства выдают нодовые узлы( среди которых может попасться на какой-нибудь текстовый узел(перенос строки)---> чтобы этого не случалось
     есть следующие свойства:
		*firstElementChild
		*.parentElement
		*.nextelementSibling, previousElementSibling
		*к сожалению для childNodes такого аналога нет(((---> его иногда делают вручную:
			иногда мы не можем перебрать псевдоколлекцию при помощи метода forEach(бывает редко, но такие случаи случаются)---> исп. for(   of   )
			////
			for(let node of document.body.childNodes){
				if(node.nodeName == '#text'){
					continue;
				}
				console.log(node);
			}
			////

БАЗА РЕКУРСИИ:
-основные понятия:
	*база рекурсии
	*шаг рекурсии - запуск вложенной функции , но уже с други значением
	*глубина рекурсии - общее количество вложенных вызовов вместе с самым первым
			
ПРИМЕР ПЕРЕБОРА ОБЪЕКТА:
////
- ищем средний прогресс у всех студентов курсов:
let students = {
	js: [{
		name: 'John',
		progress: 100
	}, {
		name: 'Ivan',
		progress: 60
	}],
	
	html: {
		basic: [{
			name: 'Peter',
			progress: 20
		}, {
			name: 'Ann',
			progress: 18
		}],
	
		pro: [{
			name: 'Sam',
			progress: 10
		}]
	}
};

function getTotalProgressByIteration(data){
	let total = 0;
	let students = 0;

	for( let course of Objects.values(data)) {
		if(Array.isArray(course)) {
			students += course.length;

			for(let i = 0; i <course.length; i++){
				total += course[i].progress;
			}
		} else {
			for(let subCourse of Object.values(course)){
				students += subCourse.length;
				
				for(let i = 0; i < subCourse.length; i++){
					total += subCourse[i].progress;
				}
			}
		}
      }
	return total/students;
}
<--- но при таком подходе нам будет нужно постоянно расширять эту функцию пр добавлении в объект новых свойств(проводить доп. проверки), поэтому легче воспользоваться 	рекурсивным методом
---> теперь создадим рекурсивный перебор с задачей, которая находится выше
- в рекурсивном методе мы не используем как в итеративном методе промежуточные переменные, так как в них нет никакой необходимости 
function getTotalProgressByRecursion(data){
	if(Array.isArray(data)) {
			let total = 0;

			for(let i = 0; i <data.length; i++){
				total += data[i].progress;
			}
				
			return [total, data.length]
	} else {
		let total =[0, 0];
		
		for(let subData of Object.values(data)){
			const  = getTotalProgressByRecursion(subData);
			total[0] += subDataArr[0];
			total[1] += subDataArr[1];
		}
		return total;
	}
}

const result = getTotalProgressByRecursion(students)
coonsole.log(result[0]/result[1]);

-Чтобы скрипт всегда работал и не было ошибок(а они могут появиться вследствие того, что скрипт будет выполняться до того как будет загружена DOM-структура(а если они не
 не загружены, то в скрипте querySelector, к примеру, будет брать несуществующий тег)--->: есть 2 способа :
1. событие load - выполнять скрипт, когда будет подгружено абсолютно всё - редко используется, так как есть случаи, когда необходимо ждать определённое количество времени
2. событие DOMContentLoaded:
////
window.addEventListener('DOMContentLoaded', () => {	// скрипт будет теперь выполняться только тогда, когда DOM-структура будет загружена(а всё остальное подгружается 				весь скрипт				         параллельно 
};
- Событие DOMContentLoaded происходит когда весь HTML был полностью загружен и пройден парсером, не дожидаясь окончания загрузки таблиц стилей, изображений и фреймов. Значительно отличающееся от него событие load используется для отслеживания только полностью загруженной страницы. 

СОБЫТИЯ МОБИЛЬНЫХ УСТРОЙСТВ:
- touchstart - обычное касание элемента
- touchmove - касание+движение
- touchend - как только палец оторвался от элемента
- touchenter - ведём пальцем по экрану и наскакиваем на элемент, на которое повешено это событие
- touchleave - палец продолжил скользить за пределами этого элемента
- touchcancel - точка соприкосновения больше не регистрируется на поверхности 
- у объекта event есть свойства:
	*touches - показывает список всех пальцев, которые находятся на экране
	*targetTouches - показывает список всех пальцев, которые взаимодействуют именно с этим элементом
	*changedTouches - список пальцев, которые участвуют в событии

 ASYNC, DEFER, ДИНАМИЧЕСКИЕ СКРИПТЫ:
- defer - атрибут, который сообщает браузеру, что он должен продолжать обрабатывать страницу и загружать скрипт в фоновом режиме, а затем выполнить скрипт, когда он загрузится. Скрипты с defer никогда не блокируют страницу. Особенность defer - скрипт будет выполняться только тогда, когда наше DOM-дерево уже готово(исключается момент, когда скрипт будет брать несуществующий тег). Срабатывает до события DOMContentLoaded
При нахождении нескольких подряд идущих подключений скриптов сохраняется последовательность их выполнения(строго по очереди(пока не выполнится первый, второй вплняться не будет)). Для чего использовать именно defer:
	1)Соблюдение порядка выполнения всех подключенных утилит(можно поставить наиболее важные скрипты в начало, а затем менее важные)
	2) Можно подключить js в любом месте html-файла( можно пометсить в head, хотя некоторые системы, такие как googleSpeedTest ругаются на таккое расположение
- async:
	*страница не ждёт асинхронных скриптов(содержимое просто обрабатываетсяи отображается)
	*события DOMContentLoaded и асинхронные скрипты не ждут друг друга
	*скрипт с атрибутом async загружается в фоновом режиме, но как только он загузился, сразу же запускается, никого не ждёт(остальные скрипты не ждут async и async  не 	ждёт остальных скриптов---> последовательность загрузки скриптов не соблюдается--->для чего это: иногда мы будем подгружать сторонние скрипты, которые не особо 	подвязаны как под DOM-структуру или под другую какую-то функциональность, например метрики и счётчики
	*используем async, когда уверены, что скрипт не зависит от DOM-структуры+ должен не зависеть от других скриптов
- динамические скрипты:
////
function loadScript(src){
	const script = document.createElement('script');
	script.src = src;
	script.async = false;	//если не установить значение false, то данный скрипт будет загружаться асинхронно
	document.body.append(script);	//добавление в конец DOM-структуры
}

loadScript("test.js");
loadScript("some.js");	//скрипты будут выполняться строго друг за другом(благодаря false)	
	*используются часто


CLASSLIST И ДЕЛЕГИРОВАНИЕ СОБЫТИЙ:
- методы classList:
	*btns[0].classList.item(номер по порядку) - получаем конкретный номер класса
	*.add('red') - добавление классов( можно перечислять через запятую
	*.remove('red')
	*.toggle('red') - убирает, если есть и ставит, если нет класс
	*.contains('red') - проверяет наличие класса( возвращает булиновое значение)
	*.className - выводит все классы
- суть делегирования - назначения функции для потомков, которые подходят под определенные параметры:
////
wrapper.addEventListener('click', (event) => {
	if (event.target(проверка на существование event.target(у некоторых тегов нет event.target(у них нет событий клика))) && event.classList.contains('blue'){
		console.log('Hello');
}

или 

wrapper.addEventListener('click', (event) => {
	if (event.target && event.target.matches('button.red'){	// matches() - значит, что какой-то элемент совпадает с чем-то
		console.log('Hello');
}
////
- делегирование - один из самых полезных приёмов для работы с DOM-деревом
- при динамическом изменении элементов, делегирование событий на эти элементы также будет срабатывать( если делать обработчик без делегирования, то если потом добавить динамически в скрипт элемент, на него не будет распространяться это событие)---> экономим место в коде


СОЗДАНИЕ ТАБОВ:
////
window.addEventListener("DOMContentLoaded", () => {
  const tabs = document.querySelectorAll(".tabheader__item"),
    tabsContent = document.querySelectorAll(".tabcontent"),
    tabsParent = document.querySelector(".tabheader__items");

  function hideTabContent() {
    tabsContent.forEach((item) => {
      item.style.display = "none";
    });
    tabs.forEach((item) => {
      item.classList.remove("tabheader__item_active");
    });
  }

  function showTabContent(i = 0) {
    tabsContent[i].style.display = "block";
    tabs[i].classList.add("tabheader__item_active");
  }

  hideTabContent();
  showTabContent();

  tabsParent.addEventListener("click", (event) => {
    const target = event.target;
    if (target && target.classList.contains("tabheader__item")) {
      tabs.forEach((item, i) => {
        if (target == item) {
          hideTabContent();
          showTabContent(i);
        }
      });
    }
  });
});

////

СКРИПТЫ И ВРЕМЯ ИХ ВЫПОЛНЕНИЯ:
- const timerId = setTimeout( function(){
	console.log('text');
}, 2000)
	*функция setTimeout() работает и без переменной, но мы определяем её, так как нам нужен идентификатор этого таймера, чтобы в дальнейшем мы могли его останавливать(очищать):
		>clearInterval(timerId)

const btn = document.querySelector('.btn');
let timerId,
	i = 0;

btn.addEventListener('click', ()=>{
	timerId = setInterval(logger, 500); 
});

function logger(){
	if(i == 3){
		clearInterval(timerId);
	}
	console.log('text');
	i++;
}
- вопрос: Чем рекурсивный setTimeout() лучше, чем setInterval? setInterval-у всё равно смколько выполняется функция(если она выполняется 3 секунды, а мы поставили таймеир на 0,5 секунд, то следующее выполнение функции будет сделано после окончания предыдущего выполнения функции сразу же(без ожидания 0,5 с, так как setInterval считает, что эти 0,5с прошли во время выполнения функции)
////
let id = setTimeout(function log(){		// работает точно также как setInteval(но он четко ждёт окончания выполнения функции, затем ждёт поставленный таймер и затем выполняет опять функцию)
	console.log('Hello');
	id = setTimeout(log, 500);			
}, 500);

////
- практика:
////
function myAnimation(){
	const elem = document.querySelector('.box'):
	let pos = 0;
	const id = setInterval(frame, 10)
	function frame() {
		if(pos == 300){
			clearInterval(id);
		} else{
			pos++;
			elem.style.top = pos + "px";
			elem.style.left = pos + "px";
		}
	}
}

btn.addEventListener('click', myAnimation);


СБОРЩИК МУСОРА И УТЕЧКА ПАМЯТИ:
- JS - высокоуровневый ЯП, интерпретируемый ЯП
- Интерпретаторы и компиляторы отвечают за преобразование языка программирования или сценариев (язык высокого уровня) в машинный код.
- Компилятор  —  это компьютерная программа, которая переводит компьютерный код с одного языка программирования на другой. Компилятор берет программу целиком и преобразует ее в исполняемый компьютерный код. Для этого требуется целая программа, так как компьютер понимает только то, что написано двоичным кодом. Задача компилятора  —  преобразовать исполняемую программу в машинный код, который и распознается компьютером. Примерами скомпилированных языков программирования являются C и C++.
Компилятор в основном используется для программ, которые переводят исходный код с языка программирования высокого уровня на язык программирования более низкого уровня.
Компилятор способен выполнять многие или даже все операции: предварительную обработку данных, парсинг, семантический анализ, преобразование входных программ в промежуточное представление, оптимизацию и генерацию кода.
- Интерпретатор  —  это компьютерная программа, которая преобразует каждый программный оператор высокого уровня в машинный код. Сюда входят исходный код, предварительно скомпилированный код и сценарии.
Интерпретатор представляет собой машинную программу, которая непосредственно выполняет набор инструкций без их компиляции. Примерами интерпретируемых языков являются Perl, Python и Matlab.
И компилятор, и интерпретатор выполняют одну и ту же работу  —  преобразовывают язык программирования высокого уровня в машинный код. Однако компилятор преобразовывает исходный материал в машинный код перед запуском программы. Интерпретатор выполняет эту функцию при ее запуске.
Сначала компилятор создает программу. Он анализирует все операторы языка, чтобы проверить, правильны они или нет. Если компилятор найдет какую-нибудь ошибку, он выдаст соответствующее сообщение. Если же он не обнаружит никаких ошибок, то преобразует исходный код в машинный. Компилятор связывает различные кодовые файлы в программы, которые можно запустить (например, формата .exe). После этого запускается программа.
Интерпретатор создает программу. Он не связывает файлы и не генерирует машинный код. Происходит построчное выполнение исходных операторов во время исполнения программы.
- Преимущества и недостатки:
Преимущества компилятора:
Программный код уже переведен в машинный, и, следовательно, требуется меньше времени на его исполнение.
Файлы .exe выполняются быстрее, чем исходный код. Объектные программы сохраняются и могут быть запущены в любое время.
Объектные программы пользователю сложнее изменить, чем исходный код.
Компилятор проверяет исходный код на наличие синтаксических ошибок во время компиляции.
Недостатки компилятора:
Поскольку переводится вся программа, она использует гораздо больше памяти компьютера.
При работе с компилятором невозможно изменить программу, не вернувшись к исходному коду.
Необходимо создавать объектную программу перед окончательным исполняемым файлом. Это может занять много времени.
Исходный код должен быть на 100% верным для создания исполняемого файла.

Преимущества интерпретатора:
Интерпретатор значительно облегчает работу с исходным кодом.
Он переводит по одной инструкции за раз, поэтому использует минимальный объем памяти.
Интерпретатор может связать сообщения об ошибках с выполняемой инструкцией, что может оказаться полезным в процессе отладки.
Недостатки интерпретатора:
Каждый раз, когда программа выполняется, тратится время на интерпретацию, из-за чего затягивается время исполнения.
Интерпретируемые программы могут выполняться только на компьютерах, на которых имеются соответствующие интерпретаторы.


- объект удаляется, как только становится недостижим(ссылка на него перестаёт существовать).Вполне возможен вариант, когда ссылка на объект есть, но она идёт не от корня(от самой глобальной переменной, которая ссылается по дереву вниз вплоть до того объекта, который нам нужен)
- утечка памяти происходит тогда, когда мы не используем объект, а сборщик мусора всё раввно его не удалил, так как объект является достижимым.
- нельзя делать следующее:
	*(без строгого режима)
	////
	function func(){
		smth = "string";	// всё равно, что напишем window.smth = "string" (объект никогда не будет удалён, так как он глобальный)
	}	
	*Использование таймеров
	////
	const someRes = getData();
	const node = document.querySelector('.class');
	
	setInterval(function() {
		if (node) {
			node.innerHTML = someRes;
		}
	}, 1000);
		>Если мы удалим node, то у нас всё равно останется этот объект достижимым( ссылка на него будет в таймере, который работает каждую секунду)---> утечка памяти---> нужно останавливать ненужные нам таймеры!
	*Обработчики событий на несуществующие элементы:
		>элемент страницы удалён,а обработчик нет---> ссылка на элемент остаётся( раньше это приводило к утечке памяти, но в современных браузерах есть механизм автоматического удаления обработчика события, если элемент, на который он повешен, был удалён)
	* Сохранение ссылок через замыкания:
		////
		function outer() {
			const a = [];
			return function inner(){
				a.push('Hello');	// заыкание (утечка памяти)
				console.log('Hello');
			}
		}
		
		const sayHello = outer();
	*Ссылки на DOM-элементы:
		////
		function createElement() {
			const div = document.createElement('div');
			div.id = 'test';
			return div;
		}
		
		const testDiv = createElement();
		document.body.append(testDiv);
		
		function deleteElement(){
			document.body.removeChild(document.getElementById('test'));
		}
		
		deleteElement();	//тут идёт удаление именно в DOM-дереве, а не в самом JS(утечка памяти)--->
	--->исправим эту ситуацию:
		function createElement() {
			const div = document.createElement('div');
			div.id = 'test';
			document.body.append(testDiv);
		}
		
		createElement();	// после срабатывания функции, её переменная div сразу же удаляется(утечки памяти больше не будет)
		
		
		function deleteElement(){
			document.body.removeChild(document.getElementById('test'));
		}
		
		deleteElement();
		
РАБОТА С ДАТАМИ:
- способы создания даты:
	////
	const now = new Date(2020, 5, 1, 20);	// месяца начинаются с 0
	console.log(now);				// 2020-06-01T17:00:00.000Z


	const now = new Date("2020-06-01");
	console.log(now);				// 2020-06-01T00:00:00.000Z

	const now = new Date(0);			// все даты отсчитываются в миллисекундах от 1970 года
	console.log(now);				// 1970-01-01T00:00:00.000Z


- методы:
	*получение компонента даты:
		////
		переменная.getFullYear()
		переменная.getMonth()
		переменная.getDate()
		переменная.getDay()  // номер дня недели(номерация начинается с воскресенья и с 0)
		////
	Все эти методы возвращают значения в соответствии с нашим часовым поясом и иногда может понадобиться другой часовой пояс (UTC (+0 часов)---> переменная.getUTCHours
		////
		переменная.getTimezoneOffset()	// разница в часовых поясах в минутах
		переменная.getTime()	//количество миллисекунд, которое прошло
	*методы установки даты:
		////
		const now = newDate();
		now.setHours(18,[следующие за ним знаачения - минуты, потом секунды])		// если у нас часовой пояс +3 часа, то выдаст время 15:00 в консоли js, так как js не ориентируется на локальные данные компьютера и выдаёт время UTC, а вот в консоли браузера уже покажется наше время 18:00

		const now = newDate("2020-06-01");   то же самое, что и     const now = newDate.parse("2020-06-01");
		

	*измерение промежутков времени:
		////
		let start = new Date();

		for(let i = 0; i < 100000; i++){
			let some = i ** 3;
		}

		let end = new Date();
		alert(`Цикл отработал за ${end - start} миллисекунд`)

ПАРАМЕТРЫ ДОКУМЕНТА, ОКНА И РАБОТА С НИМИ:
- document - объект, который хранитвсю html-структуру
- window - окно, в котором показывается документ
- screen - это весь наш монитор
- картинка со свойтсвами в папке конспекты
- высветить на экран весь текст(если он был с прокруткой):
	////
	btn.addEventListener('click', () => {
		box.style.height = box.scrollHeight + 'px';
	});

- .getBoundingClientRect() - получает все координаты, которые есть у нашей переменной, в виде объекта
-  window.getComputedStyle(переменная) - объект, со всеми окончательными стилями, которые применились к элементу. Можно получить с помощью этого способа стили, но изменять их таким образом нельзя(исп. только дя проверки чего-то)
- в JS нельзя работать с псевдоэлемента(нет доступа к ним), но стили псведоэлементов получить можно: window.getComputedStyle(переменная, псведоэлемент)


- нельзя сделать так: document.scrollTop() (такого свойства не существует) ----> правильно будет: document.documentElement.scrollTop()
- window.scrollBy(0, 400)     то же самое,что и     document.documentElement.scrollBy(0, 400)			// относительно нынещнего положения скролл на 400px
- window.scrollTo(0,300)	//относительно всей страницы.


СОЗДАНИЕ МОДАЛЬНЫХ ОКОН:
////
  const btn = document.querySelectorAll("[data-modal]"),
    modal = document.querySelector(".modal"),
    closeMod = document.querySelector("[data-close]");

  btn.forEach((item) => {
    item.addEventListener("click", () => {
      modal.style.display = "block";
      /* myMod/classList.add('show'); */
      document.body.style.overflow = "hidden";
    });
  });

  function closeModal() {
    modal.style.display = "none";
    document.body.style.overflow = "";
  }
  closeMod.addEventListener("click", closeModal);

  modal.addEventListener("click", (e) => {
    if (e.target.classList.contains("modal")) {		// при нажатии на пустоту окно закрывается
      closeModal();
    }
  });
////
- события клавиатурных клавиш:
	////
  document.addEventListener("keydown", (e) => {
    if (e.code == "Escape" && modal.style.display == "block") {
      closeModal();
    }
  });
	////
- Открытие окна через 5 секунд после открытия сайта,при этом, если пользователь сам открыл модальное окно до того, как прошло 5 секунд, то мы очищаем интервал, чтобы модальное окноне открывалось повторно
function openModal() {
    modal.style.display = "block";
    document.body.style.overflow = "hidden";
    clearInterval(modalTimerId);
  }
const modalTimerId = setTimeout(openModal, 5000);
- 
////
function showModalByScroll() {
    if (
      document.documentElement
        .scrollTop /* можно также воспользоваться свойством window.pageYOffset */ +
        document.documentElement.clientHeight >=
      document.documentElement.scrollHeight
    ) {
      openModal();
    }
    window.removeEventListener("scroll", showModalByScroll);
  }

MUTATIONOBSERVER: НАБЛЮДАТЕЛЬ ЗА ИЗМЕНЕНИЯМ:
- MutationObserver – это встроенный объект, наблюдающий за DOM-элементом и запускающий колбэк в случае изменений.
- работа идёт с результатом изменения( нельзя запретит, например, ввод каких-либо букв)
- это асинхронная операция( отслеживание может выполниться чуть попозже или чуть-чуть раньше, в зависимости от различных условий. Именно поэтому мы получаем массив(набор изменений, которые произошли))
- Сначала мы создаём наблюдатель за изменениями с помощью колбэк-функции:
////
let observer = new MutationObserver(callback);
////
Потом прикрепляем его к DOM-узлу:
////
observer.observe(node, config);
////
config – это объект с булевыми параметрами «на какие изменения реагировать»:
childList – изменения в непосредственных детях node,
subtree – во всех потомках node,
attributes – в атрибутах node,
attributeFilter – массив имён атрибутов, чтобы наблюдать только за выбранными.
characterData – наблюдать ли за node.data (текстовое содержимое),

////
// Выбираем целевой элемент
var target = document.getElementById('some-id');

// Конфигурация observer (за какими изменениями наблюдать)
const config = {
    attributes: true,
    childList: true,
    subtree: true
};

// Колбэк-функция при срабатывании мутации
const callback = function(mutationsList, observer) {
    for (let mutation of mutationsList) {
        if (mutation.type === 'childList') {
            console.log('A child node has been added or removed.');
        } else if (mutation.type === 'attributes') {
            console.log('The ' + mutation.attributeName + ' attribute was modified.');
        }
    }
};

// Создаём экземпляр наблюдателя с указанной функцией колбэка
const observer = new MutationObserver(callback);

// Начинаем наблюдение за настроенными изменениями целевого элемента
observer.observe(target, config);

// Позже можно остановить наблюдение
observer.disconnect();
/////

ФУНКЦИИ-КОНСТРУКТОРЫ:
- функции по своей сути являются объектами и по идее в нее можно записать какие-то методы и свойства
- старый способ задания объекта:
////
const num = new Number(3)
console.log(num)	// [Number:3]	///создали объект

const num = new Function(3)
console.log(num)	// [Function:anonymous]	///создали функцию(объект, свойства которого уже прописаны в этой функции)
////
- нормальный синтаксис:
////
function User(name, id){
	this.name = name;	// свойства, которые будут отображаться точно также как и в объекте
	this.id = id;
	this.human = true;
	this.hello = function() {
		console.log(`Hello ${this.name}`);	// создание метода
	};
}	// теперь мы можем создавать новых пользователей

const ivan = new User('Ivan', 28')	// внутри переменной будет находиться не функция, а объект, потому что функция User стала конструктором, при вызове которого создаётся объект с теми свойствами, с которыми мы 
 					   его записали
////
- такая функция по факту - прототип, от которого мы можем отпочковывать разные объекты( которые будут относиться к 1 категории(как легковые авто)
- с помощью метода prototype можно добавлять новые методы или свойства в конструктор(этот приём используется, когда нет доступа к прототипу или мы не можем его менять, но нужно что-то добавить):
////
User.prototype.exit = function(){
		console.log(`Пользователь ${this.name} ушёл`);
	}
////
- Конструкторы нужны для создания новых однотипных объектов. В практике это могут быть новые пользователи на сайтах, товары в магазинах, ролики на ютубе
- Всё, что мы рассмотрели выше является стандартом ES5(то как на самом деле всё происходит под капотом JS)---> в ES6 появились классы - синтаксический сахар, то есть красивая обёртка функционала, который существует на
  самом деле( их удобнее использовать)

КОНТЕКСТ ВЫЗОВА.THIS:
- это то, что окружает функцию и то, в каких условиях она вызывается
- если мы просто запускаем функцию, то this будет ссылаться на глобальный объект window(это правило верно для обычного режима(без use strict)). с use strict - this будет иметь значение undefined
- если мы используем функцию внутри функции, контект у неё не меняется( либо window, либо undefined). Так работает всегда для всех функций
- контект у методов объекта - это сам объект (но если мы пропишем функцию отдельную внутри самого метода, то контекст вызова данной функции будет такой же, как и во всех функциях)
- для всех функций-конструкторов контекстом вызова будет являться только что созданный объект . То есть this  в конструкторах и классах - это новый экземляр объекта!
- 2 варианта ручного присвоения контекста:
////
function sayName(surname){
	console.log(this);
	console.log(this.name + surname);
}
const user = {
	name: 'John'
}

sayName.call(user, 'Smith');
sayName.apply(user, ['Smith']);	// 2 способа , просто разные синтаксисы присвоения аргументов функции
////
3 способ:
- создаёт новую функцию, связанную с определённым контекстом:
////
function count(num){
	return this*num;
}
	
const double = count.bind(2)	// this будет равняться 2 у double всегда
console.log(double(3));		// 3 - это аргумент
////

- Когда у нашего обработчика события функция написана вот так( function(){}), то контекстом вызова(this) будет элемент, с которым произошло событие
- у стрелочной функции нет своего контекста вызова, она всегда будет брать его у своего родителя( то есть как уже писали выше, если бы мы поместили функцию в метод объекта , то this было бы undefined, но в случае
  стрелочной функции this будет ссылаться на контекст вызова его родителя, то есть на метод объекта, а тот в свою очередь будет ссылаться на объект). А при нахождении стрелочной функции в обработчике событий, контекст
  вызова будет либо undefined, либо window

КЛАССЫ ES6:
- по простому классы - это красивая обёртка функций-конструкторов
////
class Rectangle{
	constructor(height, width){   
		this.heught = height;
		this.width = width;
	}
	calcArea(){
		return this.height*this.width;
	}
}
////
- принципы ООП:
1.Абстракция - когда мы отделяем концепцию от её экземпляра
2.Наследование- способность нашего объекта или класса базироваться на другом объекте или классе(большой класс title(различные статьи на сайте), чуть позже сайт разрастается и нам уже нужно сделать статьи, которые будут 
 под разными рубриками. Соответственно каждая из этих статей будут немножко кастомизироваться, при этом они будут прототипом, на основе которых уже будет что-то создаваться, соотвестственно у нас уже идёт иерархия, где
 есть главный класс title, далее идёт распредление на различные тематики)
////
class ColoredRectangleWithText extends Rectangle{
	constructor(height, width, text, bgColor){
		super();	// метод,который вызывает конструктор родителя(всегда должно быть на 1 месте)
		this.text = text;
		this.color = bgColor;
	}
	showMyprops(){
		console.log(......);
}

КЛАССЫ В РЕАЛЬНОЙ РАБОТЕ:
////
 class MenuCard {
    constructor(src, alt, title, descr, price, parentSelector) {
      this.src = src;
      this.alt = alt;
      this.title = title;
      this.descr = descr;
      this.price = price;
      this.parent = document.querySelector(parentSelector)
      this.transfer = 27;
      this.changeToUAH();
    }

    changeToUAH() {
      this.price = this.price * this.transfer;
    }

    render() {
      const element = document.createElement('div');
      element.innerHTML = `
          <div class="menu__item">
            <img src=${this.src} alt=${this.alt} />
            <h3 class="menu__item-subtitle">Меню "Фитнес"</h3>
            <div class="menu__item-descr">
              ${this.descr}
            </div>
            <div class="menu__item-divider"></div>
            <div class="menu__item-price">
              <div class="menu__item-cost">Цена:</div>
              <div class="menu__item-total"><span>${this.price}</span> грн/день</div>
            </div>
          </div>
      `
      this.parent.append(element)

    }

  }

  new MenuCard(
    "img/tabs/vegy.jpg",
    "vegy",
    'Меню "Фитнес"',
    'Меню "Фитнес" - это новый подход к приготовлению блюд: больше свежих овощей и фруктов. Продукт активных и здоровых людей. Это абсолютно новый продукт с оптимальной ценой и высоким качеством!',
    9,
    '.menu .container'
  ).render();
////
- чтобы не прописывать так каждый раз, как мы делали выше, напиешм следующий код:
////
  getResources('http://localhost:3000/menu')
    .then(data => {
      data.forEach(({img, alt, title, descr, price}) => { /* деструктуризация объекта */		//данные о формах будут находиться на сервере
        new MenuCard(img, alt, title, descr, price, '.menu .container').render();
      })
    })
////
- 2-ой варинт без использования классов:
////
  const getResources = async (url, data) => {
    const res = await fetch(url)
    if (!res.ok) {
      throw new Error(`Could not fetch ${url}, status: ${res.status}`);
    }
    return res.json();
  }
  getResources('http://localhost:3000/menu')
    .then(data => createCard(data));

  function createCard(data) {
    data.forEach(({
     img, altimg, title, descr, price
    }) => {
      const element = document.createElement('div');

      element.classList.add('menu__item');
      element.innerHTML = `
      <img src=${img} alt=${altimg} />
      <h3 class="menu__item-subtitle">Меню "Фитнес"</h3>
      <div class="menu__item-descr">
        ${descr}
      </div>
      <div class="menu__item-divider"></div>
      <div class="menu__item-price">
        <div class="menu__item-cost">Цена:</div>
        <div class="menu__item-total"><span>${price}</span> грн/день</div>
      </div>
      `;
      document.querySelector('.menu .container').append(element);
    })
  }
////
REST-ОПЕРАТОР И ПАРАМЕТРЫ ПО УМОЛЧАНИЮ:
- Синтаксис остаточных параметров функции позволяет представлять неограниченное множество аргументов в виде массива(если ничего не передали, то массив будет пустой)
////
function sum(...theArgs) {
  let total = 0;
  for (const arg of theArgs) {
    total += arg;
  }
  return total;
}
console.log(sum(1, 2, 3));
// expected output: 6
console.log(sum(1, 2, 3, 4));
// expected output: 10
////
- Параметры по умолчанию позволяют задавать формальным параметрам функции значения по умолчанию в случае, если функция вызвана без аргументов, или если параметру явным образом передано значение undefined.
////
function multiply(a, b = 1) {
  return a * b;
}
////
Старый способ:
//// 
function multiply(a, b) {
  b = b || 1;
  return a * b;
}
////

СОЗДАНИЕ ТАЙМЕРА ОБРАТНОГО ОТСЧЁТА НА САЙТЕ:
////

  const deadline = '2022-08-07';

  function getTimeRemaining(endtime) {
    let days, hours, minutes, seconds;
    const t = Date.parse(endtime) - Date.parse(new Date());
    if (t <= 0) {
      days = 0;
      hours = 0;
      minutes = 0;
      seconds = 0;
    } else {
      days = Math.floor(t / (1000 * 60 * 60 * 24)),
        hours = Math.floor(t / (1000 * 60 * 60) % 24),
        minutes = Math.floor((t / 1000 / 60) % 60),
        seconds = Math.floor((t / 1000) % 60);
    }

    return {
      'total': t,
      'days': days,
      'hours': hours,
      'minutes': minutes,
      'seconds': seconds
    };
  }

  function setClock(selector, endtime) {
    const timer = document.querySelector(selector),
      days = timer.querySelector('#days'),
      hours = timer.querySelector('#hours'),
      minutes = timer.querySelector('#minutes'),
      seconds = timer.querySelector('#seconds');
    timeInterval = setInterval(updateClock, 1000)

    updateClock(); // чтобы сразу показывало правильное время на странице(в противном случае будет выведено на первую секунду значение по умолчанию deadline)

    function getZero(num) {
      if (num >= 0 && num < 10) {
        return `0${num}`;
      } else {
        return num;
      }
    }

    function updateClock() {
      const t = getTimeRemaining(endtime);

      days.innerHTML = getZero(t.days);
      hours.innerHTML = getZero(t.hours);
      minutes.innerHTML = getZero(t.minutes);
      seconds.innerHTML = getZero(t.seconds);

      if (t.total <= 0) {
        clearInterval(timeInterval);
      }
    }


  }

  setClock('.timer', deadline);
////


ЛОКАЛЬНЫЕ СЕРВЕРА:
- Сервер - это программа, которая позволяет запускать сайты и выполнять более сложные операции. Это backend-часть. Там используются серверные языки программирования и также стоят интерпретаторы и эту часть мы не видим.
- Хостинг- это когда мы покупаем определенное место, определённую папку у хостинг-провайдера. Всё, что мы поместим в папку, которая будет записана нашим доменным именем( если оно зарегистрировано), то это всё отобразится
 в интернете. Но чтобы всё это произошло нам необходимо, чтобы хостинг провайдер постоянно имел включённый сервер. 
- Локальные сервера позволяют запустить такой же функционал в пределах нашего комппьютера. 
- Классификация локальных серверов:
	*простые - выполняют несколько задач(live server(только get-запросы), browsersync(только get-запросы), http-сервер(выполняют get и post-запросы, json-сервер) - обновлениепри изменении кода, получение доступа к сайту через wifi-сеть
	*комплексные - выполняют всё, что только можно
JSON-ФОРМАТЫ ПЕРЕДАЧИ ДАННЫХ, ГЛУБОКОЕ КЛОНИРОВАНИЕ ОБЪЕКТОВ:
- JSON-формат - текстовый формат обмена данными, а также формат хранения данных. Изначально появился в JS, однако сейчас используется абсолютно любмы языком программирования.
- это всего лишь набор пар ключ-значение
- все строчки должны быть обязательно в двойных кавычках
- напрямую передавать данные из JS мы не можем, так как сервер и протоколы передачи данных нас не поймут---> нам нужно превратить в нужный формат данные 
- все современные браузеры имеют встроенные объекты json для работы с этими данными и в этом встроенном объекте есть как свойства, так и методы
- методы встроенного объекта json в браузерах:
	*stringify - превращает объект JS в нужный нам формат
	*parse - превращает объект формата JSON в объект формата JS
- причина популярности JSon-формата - это его маленький вес файла + простота чтения даже для человека
- до появления json использовался формат XML
- глубокие копии объектов создаются как раз-таки с помощью методов JSON:
	////
	const clone = JSON.parse(JSON.stringify(persone))
	////

AJAX И ОБЩЕНИЕ С СЕРВЕРОМ:
- для общения с сервером необходимы http-запросы
- чтобы всё это происходилоо асинхронно, то есть без перезагрузки страницы, нужна технология AJAX
- плюсы AJAX:
	*красивая подгрузка отдельных элементов страницы
	*ускорение интерфейса страницы, так как мы не перезагружаем страничку полностью---> уменьшение нагрузки на сервер + экономия траффика пользователя
- минусы AJAX:
	*у пользователя всегда должен быть включён JS
	* при плохом соединении с интернетом может быть некорректное поведение ( что-то может недогрузиться или подвиснуть)
- разница в событиях change и input:
	*change - когда сменяется фокус на форме
	*input - когда что-то вводится или удаляется
- методы объекта XMLHTTPRequest:
	*open(method, url, async, login, pass) - собирает настройки, которые в будущем помогут сделать запрос. Аргументы: method - метол, кот.ю используется для запроса(get или post), url - путь к серверу, async - изначально в позиции 
	 true
- запросы мы посылаем из HTML-файла, именно на нём работают скрипты, поэтому в url указываем путь относительно html
////
const request = new XMLHTTPRequest();
request.open('GET', 'js/current.json') 
////
- http-заголовки:
	*с помощью заголовка мы даём знать серверу какая информация передаётся, как она закодирована(делается это для того, чтобы транспортные протоколы понимали, что они передают и когда они приходят на сервер, сервер
	 точно понимал, что он принимает, что он принимает в себя)
	*заголовок для передачи json-файлов:
	////
	.setRequestHeader('Content-type','application/json; charset=utf-8')
	////
- .send(body) - для отправки запроса(выполняет то, что написали в .open()).Аргумент body - это то, что может уходить на сервер( существует только в post и ещё в паре методов)
- свойства объекта XMLHttpRequest:			
	*status - статсу нашего запроса (например 404(not found))
	*statusText - текстовое описание ответа от сервера
	*response - ответ от сервера(ответ, который нам задал backend-разработчик - то, что мы должны использовать на клиенте)
	*readyState - текущее состояние нашего запроса
- события, относящиеся к объекту XMLHttpRequest:
	*'readystatechange' - отслеживает готовность нашего запроса в данный текущий момент(следит за свойством readyState):
		////
		request.addEventListener('readystatechange', () => {
			if (request.readyState === 4 && request.status ==== 200) {
				console.log(request.respone);
				const data = JSON.parse(request.response);
			} else {
				console.log("Что-то пошгло не так");
			}
		});
		
	*'load' - срабатывает 1 раз, когда запрос уже полностью готов:
		////
		request.addEventListener('readystatechange', () => {
			if ( request.status ==== 200) {			// без request.readyState
				console.log(request.respone);
				const data = JSON.parse(request.response);
			} else {
				console.log("Что-то пошгло не так");
			}
		});
- Реализация скрипта отправки данных на сервер:
////
const forms = document.querySelectorAll('form');
const message = {
	loading: 'Загрузка' ,
	success: 'Спасибо, скоро мы с вами свяжемся' ,
	failure: 'Что-то пошло не так' 
};

forms.forEach(item=> {
	postData(form);
});

	function postData(form) {
		form.addEventListener('submit',(e) => {
			e.preventDefault();

			const statusMessage = document.createElement('div');
			statusMessage.classList.add('status');
			statusMessage.textContent = message.loading;
			form.append(statusMessage);
	
				
			const request = new XMLHttpRequest();
			request.open('POST','server.php');
			
			request.setRequestHeader('Content-type','multipart/form-data');		//!!!!! для объектов XMLHttpReauest() и formData() заголовк утанавливать не нужно, а вот для JSON-файла нужно
			const formData = new FormData(form);					// если в вёртске не указаны атрибуты name , будут скорее всего ошибки при формаровании объекта
		
			request.send(formData);
			
			request.addEventListener('load',() => {
				if (request.status === 200) {
					console.log(request.response);
					statusMessage = message.success;
					form.reset();
					setTimeout(()=> {
						statusMessage.remove();
					}, 2000);
				} else {
					statusMessage = message.failure;
			}
////
ЕСЛИ НУЖЕН JSON-файл--->
////
	const request = new XMLHttpRequest();
			request.open('POST','server.php');
			
			request.setRequestHeader('Content-type','application/json');		
			const formData = new FormData(form);	
			
			const object = {};
			formData.forEach(function(key,value){
				object[key] = value;
			});
			const json = JSON.stringify(object);
				
		
			request.send(json);
////
 //более элегантный способ преображения form-data в json :
        const json = JSON.stringify(Object.fromEntries(formData.entries())) /* берём фоform-data и превращаем в массив массивов--> превращение в обычный объект(обратная операция - 
          fromEntries()---> и далее превращаем объект в json) */
на server.php прописать:
	////
	<?php
	$_POST = json_decode(file_get_contents("php://input"),true);	// только для json-файла
	echo var_dump($_POST);	// эта команда берёт данные, которые пришли на сервер, превращает их в строку и показывает нам обратно на клиенте
	////


КРАСИВОЕ ОПОВЕЩЕНИЕ ПОЛЬЗОВАТЕЛЯ:
////

  const forms = document.querySelectorAll('form');
  const message = {
    loading: 'img/tabs/spinner.svg',
    success: 'Спасибо, скоро мы с вами свяжемся',
    failure: 'Что-то пошло не так'
  };

  forms.forEach(item => {
    postData(item);
  });

  function postData(form) {
    form.addEventListener('submit', (e) => {
      e.preventDefault();

      const statusMessage = document.createElement('img');
      statusMessage.src = message.loading;
      statusMessage.style.cssText = `
      display:block;
      margin: 0 auto;
      `
      // form.append(statusMessage); /* в некоторых местах будет некорректно располагаться */

      form.insertAdjacenElement('afterend', statusMessage);
      


      const request = new XMLHttpRequest();
      request.open('POST', 'server.php');

      const formData = new FormData(form); // если в вёртске не указаны атрибуты name , будут скорее всего ошибки при формаровании объекта

      request.send(formData);

      request.addEventListener('load', () => {
        if (request.status === 200) {
          console.log(request.response);
          showThanksModal(message.success);
          form.reset();
          statusMessage.remove();
        } else {
          showThanksModal(message.failure);
        }
      });
    });
  }

  function showThanksModal(message) {
    const prevModalDialog = document.querySelector('.modal__dialog');

    prevModalDialog.style.display = 'none';
    openModal();

    const thanksModal = document.createElement('div');
    thanksModal.classList.add('modal__dialog');
    // динамичекси созданные элементы не работают с обработчиками событий, если не прописать через делегирование событий
    thanksModal.innerHTML = `
            <div class="modal__content">
            <div class="modal__close" data-close >×</div>         
            <div class="modal__title">${message}</div>
            </div>
        `;
    document.querySelector('.modal').append(thanksModal);
    setTimeout(() => {
      thanksModal.remove();
      prevModalDialog.style.display = "";
      closeModal();
    }, 4000)
  }

});
////

PROMISE:
- позволяет успешно и удобно работать с асинхронными операциями(2 вида асинхр. операций: 1.таймауты; 2. операция с сервером(мы не знаем, когда сервер выполнит её))
- promise - обещания
- если произошло что-то, то мы обещаем, что выполнится какое-то действие
- необходима цепочка действий. Чтобы выполнить промис, нужно, чтобы какое-то действие сначала выполнилось---> для такого кода можно написать множество колбэк вызовов, но он будет нечитабельным
////
const req = new Promise(function (resolve, reject){	// обещание может заверишться как положительно, так и отрицательно
	....						// resolve и reject - это аргументы, вместо которых будут подставляться функции
	const product = {
		name: 'TV',
		price: 2000
	};
	
	resolve(product);
});
							// дальше мы должны обработать все эти варианты
req.then((product) => {					// метод .then() принимает внутри себя аргумент с функцией - resolve
	console.log(data);				//с reject то же самое, только используется метод .catch()
}
////
- с помощью промисов мы добиваемся, чтобы наш код был последовательным, несмотря на то, что он асинхронный
- с помощью метода .finally() прописываются действия, которые должны происходить всегда(при любом исходе промиса)
- Promise.all([....]).then() - метод, который выполняет действие при выполнении всех стоящих в скобках промисов
- Promise.race([....]).then() - метод, который выполняет действие после выполнения первого промиса

FETCH API:
- API - это обобщаяющее понятие
- API - по простому, это набор данных и возможностей, которые предоставляют нам какое-то готовое решение
- API - это интерфейс, с которым мы можем работать
- API, который мы знаем - это DOM API - по факту это различные методы, которые позволяют работать с элементами на странице
- FETCH API - технология, позволяющая общаться с ервером и она построена на промисах
////
fetch(url, на который посылаем запрос)			//если больше ничего не указывать, то будет классический GET-запрос  + из этой конструкции возвращается промис
	.then(response => response.json());		// метод .json() - превращает данные в формате json  в самый обычный js-объект    + команда response.json() возвращает нам промис, чтобы мы построили цепочку далее
	.then(json => console.log());
////
- другие виды запросов:
////
fetch(url, на который посылаем запрос, { 
 	method: "POST",
 	body: JSON.stringify({name: 'Alex'}),
	headers: {
		'Content-type': 'application/json'
	}
	});
////
----> теперь вместо XMLHttpRequest мы будем использовать fetch()
////
// ОТПРАВЛЕНИЕ JSON-ФАЙЛА

      const formData = new FormData(form); // если в вёртске не указаны атрибуты name , будут скорее всего ошибки при формаровании объекта

      const object = {};
			formData.forEach(function(key,value){
				object[key] = value;
			});

      fetch('serv1er.php', {
        method: 'POST',
        headers: {
          'Content-type': 'application/json'
        },
        body: JSON.stringify(object)
      })
      .then(data => data.text())    /* прописали это, чтобы чётко понимать какой ответ приходит от сервера */
      .then(data => {
        console.log(data);
        showThanksModal(message.success);
        statusMessage.remove();
      })
      .catch(() => {
        showThanksModal(message.failure);
      })
      .finally(() => {
        form.reset();
      })
 /////         

// ОТПРАВЛЕНИЕ FORM-DATA:

// const formData = new FormData(form); // если в вёртске не указаны атрибуты name , будут скорее всего ошибки при формаровании объекта


// fetch('server.php', {
//   method: 'POST',
//   body:  formData
// })
// .then(data => data.text())    /* прописали это, чтобы чётко понимать какой ответ приходит от сервера */
// .then(data => {
//   console.log(data);
//   showThanksModal(message.success);
//   statusMessage.remove();
// })
// .catch(() => {
//   showThanksModal(message.failure);
// })
// .finally(() => {
//   form.reset();
// })
////

- если внутри fetch() промис попадает на ошибку, которая связана с HTTP-протоколом(404, 502), он не выдаст reject(для него это не считается ошибкой) и нормально выполнит resolve---> reject сработает только если про-
  изойдёт сбой в сети(отключённом интернете) или если что-то помешало запросу выполниться--->2 свойства:
	*.ok - говорит дословно - мы что-то получили и всё окей, либо не окей
	*.status - статус запроса
////
  const getResources = async (url, data) => {
    const res = await fetch(url)
    if(!res.ok){
      throw new Error(`Could not fetch ${url}, status: ${res.status}`);
    }
    return res.json();
  }
////

МЕТОДЫ ПЕРЕБОРА МАССИВОВ:\
- метод .forEach() перебирает массив и НЕ ВОЗВРАЩАЕТ новый 
- каждый последующий возвращает новый массив
- filter:	
////
const names =  ['Ivan', 'Ann', 'Ksenia', 'Voldemart'];
const shortNames = names.filter(name => name.length < 5)
////
- map:	// позволяет взять исходный массив и изменить каждый элемент внутри него
////
const shortNames = names.filter(name => name.toUpperCase());
////
- every/some		// возвращают булиновое значение
	*every - каждый элемент должен соответствовать условию
	*some - хотя бы 1 элемент должен соответствовать условию
////
const some = [4, 'qw', 'dfvdsvsdf'];
some.some( item => typeof(item) === 'number');			// true
////
-reduce:	служит для того, чтобы схлопывать или собирать массив в одно единое целое
////
const arr = [4,5,2,3,1];
const result = arr.reduce((sum, current) => sum + current)	// sum в момент запуска равен первому элементу массива; current тот непосредственный элемент по очереди, который приходит из массива

const str = ['apple', 'android', 'xiaomi']	
const text = str.reduce((sum, current) => `${sum}, ${current}`);
////
	*const result = arr.reduce((sum, current) => sum + current, 3)	// в данном случае sum будет равняться изначально 3
////

-Способ сделать из объекта массив:
////
const newArr =  Object.entries(obj)	// будет массив из массивов



NPM И ПРОЕКТ. JSON-СЕРВЕР:
- желательно устанавливать пакеты локально( для того, чтобы они не работали во всех проектах, чтобы вы знали какая именно версия нужна конкретно для данного проекта, чтобы пользователи, скачивающие ваш проект не ка-
  чали ненужные глобальные пакеты(он будет чётко значть какие именно пакеты ему будут нужны для проекта))
- если пакет будет использоваться только в течение разработки, то ставим флаг --save-dev

ПОЛУЧЕНИЕ ДАННЫХ С СЕРВЕРА. ASYNC/AWAIT(ES8):
////
  const postData = (url, data) => {
    const res = fetch(url, {
      method: 'POST',
      headers: {
        'Content-type': 'application/json'		//Если мы запишем так наш код, то будет ошибка, так как фуцнкция fetch() - асинхронная---> в res будет пусто--->операторы ASYNC/AWAIT
      },
      body: data
    })
    return await res.json();		// в .json() возвращается промис
  }
////
- с помощью операторов async/await мы убираем асинхронность - говорим коду - подожди, пока выполнится эта операция
////

  const postData = async (url, data) => {
    const res = await fetch(url, {
      method: 'POST',
      headers: {	
        'Content-type': 'application/json'		// ВОТ ТАК ВСЁ БУДЕТ РАБОТАТЬ КОРРЕКТНО 
      },
      body: data
    })
    return res.json();
  }
////


ЧТО ТАКОЕ БИБЛИОТЕКИ. БИБЛИОТЕКА AXIOS:
- библиотека - это маленький участок кода или большой ресурс, который решает какую-либо проблему
- когда вы понимаете, как работает JS  и все его особенности внутри, вам совершенно неважно как выглядит и называется библиотека - они все работают по похожим принципам
- ДЛЯ ИСПОЛЬЗОВАНИЯ БИБЛИОТЕКИ НЕОБХОДИМО ПОМЕЩАТЬ ЕЁ В HTML ПЕРЕД НАШИМ СКРИПТОМ
- axios - удобный ресурс, который позволяет работать с сервером
- в axios есть автоматическое преобразование json-файла
- отличие axios от fetch в том, что возвращает нам более подробный ответ 

СОЗДАНИЕ СЛАЙДЕРА НА СТРАНИЦЕ:
////

  const slides = document.querySelectorAll('.offer__slide'),
  prev = document.querySelector('.offer__slider-prev'),
  next = document.querySelector('.offer__slider-next'),
  total = document.querySelector('#total'),
  current = document.querySelector('#current');
  let slideIndex = 1;

  showSlides(slideIndex);

  if (slides.length < 10) {
    total.textContent = `0${slides.length}`
  } else {
    total.textContent = slides.length;
  }

  function showSlides(n) {
    if (n > slides.length) {
      slideIndex = 1;
    }

    if (n < 1) {
      slideIndex = slides.length;
    }

    slides.forEach(item => item.style.display = 'none')
    slides[slideIndex - 1].style.display = 'block';

    if (slides.length < 10) {
      current.textContent = `0${slideIndex}`
    } else {
      current.textContent = slideIndex;
    }

  }

  function plusSlides(n) {
    showSlides(slideIndex += n)
  }

  prev.addEventListener('click', () => {
    plusSlides(-1);
  });


  next.addEventListener('click', () => {
    plusSlides(1);
  });

////
